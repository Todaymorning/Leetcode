// 213. æ‰“å®¶åŠ«èˆ II
// labuladong é¢˜è§£æ€è·¯
// ä¸­ç­‰
// ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ï¼Œæ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ã€‚è¿™ä¸ªåœ°æ–¹æ‰€æœ‰çš„æˆ¿å±‹éƒ½ å›´æˆä¸€åœˆ ï¼Œè¿™æ„å‘³ç€ç¬¬ä¸€ä¸ªæˆ¿å±‹å’Œæœ€åä¸€ä¸ªæˆ¿å±‹æ˜¯ç´§æŒ¨ç€çš„ã€‚
// åŒæ—¶ï¼Œç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ ã€‚
// ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  åœ¨ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œä»Šæ™šèƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚

// ç¤ºä¾‹ 1ï¼š
// è¾“å…¥ï¼šnums = [2,3,2]
// è¾“å‡ºï¼š3
// è§£é‡Šï¼šä½ ä¸èƒ½å…ˆå·çªƒ 1 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 2ï¼‰ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 2ï¼‰, å› ä¸ºä»–ä»¬æ˜¯ç›¸é‚»çš„ã€‚

// ç¤ºä¾‹ 2ï¼š
// è¾“å…¥ï¼šnums = [1,2,3,1]
// è¾“å‡ºï¼š4
// è§£é‡Šï¼šä½ å¯ä»¥å…ˆå·çªƒ 1 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 1ï¼‰ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 3ï¼‰ã€‚
//      å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ = 1 + 3 = 4 ã€‚

// ç¤ºä¾‹ 3ï¼š
// è¾“å…¥ï¼šnums = [1,2,3]
// è¾“å‡ºï¼š3

// æç¤ºï¼š
// 1 <= nums.length <= 100
// 0 <= nums[i] <= 1000


#include<iostream>
#include<vector>
using std::vector;

class Solution {
public:
    int rob(vector<int>& nums) {

    }
};

// 10:46--10:48(è¯»é¢˜æ‰¾æ€è·¯)--11:01(ä¸ä¼š)--11:31(çœ‹ D1 çš„æ€è·¯å†™)
// å¯¹äºä¸€ä¸ªæ•°ç»„ï¼Œæˆç¯çš„è¯ä¸»è¦æœ‰å¦‚ä¸‹ä¸‰ç§æƒ…å†µï¼š
// æƒ…å†µä¸€ï¼šè€ƒè™‘ä¸åŒ…å«é¦–å°¾å…ƒç´ 
// æƒ…å†µäºŒï¼šè€ƒè™‘åŒ…å«é¦–å…ƒç´ ï¼Œä¸åŒ…å«å°¾å…ƒç´ 
// æƒ…å†µä¸‰ï¼šè€ƒè™‘åŒ…å«å°¾å…ƒç´ ï¼Œä¸åŒ…å«é¦–å…ƒç´ 
// è¾“å…¥
// nums =
// [1]
// è¾“å‡º
// 0
// é¢„æœŸç»“æœ
// 1
// è¾“å…¥
// nums =
// [1,1]
// è¾“å‡º
// 0
// é¢„æœŸç»“æœ
// 1
// è¾“å…¥
// nums =
// [1,3,1,3,100]
// è¾“å‡º
// 101
// é¢„æœŸç»“æœ
// 103
// æ—¶é—´å¤æ‚åº¦: O (n)
// ç©ºé—´å¤æ‚åº¦: O (n)
class Solution {
    // [start, end]
    int robRange(vector<int>& nums, int start, int end) {
        int len = end - start + 1;
        if(len <= 0) return 0;
        if(len == 1) return nums[start];
        vector<int> dp(len, 0);
        dp[0] = nums[start];
        dp[1] = std::max(dp[0], nums[start + 1]);   // ***
        for(int i=2; i<len; i++) {
            dp[i] = std::max(dp[i-1], dp[i-2] + nums[start + i]);
        }
        return dp.back();
    }
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];    // ***
        int left = robRange(nums, 0, nums.size() - 2);
        int right = robRange(nums, 1, nums.size() - 1);
        return std::max(left, right);
    }
};



// æ³¨æ„ï¼šcpp ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç å·²ç»é€šè¿‡åŠ›æ‰£çš„æµ‹è¯•ç”¨ä¾‹ï¼Œåº”è¯¥å¯ç›´æ¥æˆåŠŸæäº¤ã€‚

class Solution_L1_copy {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];

        vector<int> memo1(n, -1);
        vector<int> memo2(n, -1);
        // ä¸¤æ¬¡è°ƒç”¨ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„å¤‡å¿˜å½•
        return std::max(
                dp(nums, 0, n - 2, memo1),
                dp(nums, 1, n - 1, memo2)
        );
    }

    // å®šä¹‰ï¼šè®¡ç®—é—­åŒºé—´ [start,end] çš„æœ€ä¼˜ç»“æœ
    int dp(vector<int>& nums, int start, int end, vector<int>& memo) {
        if (start > end) {
            return 0;
        }

        if (memo[start] != -1) {
            return memo[start];
        }
        // çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        int res = std::max(
                dp(nums, start + 2, end, memo) + nums[start],
                dp(nums, start + 1, end, memo)
        );

        memo[start] = res;
        return res;
    }
};