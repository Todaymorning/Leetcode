// LRU 算法，全称为最近最少使用（Least Recently Used）算法，是一种常见的缓存淘汰策略。
// 该算法的核心思想是，当内存空间不足时，优先淘汰最近最少使用的数据。
// 这一策略基于一个假设，即最近被访问过的数据在未来被访问的可能性更大。
// LRU 算法广泛应用于各种缓存系统，如数据库、Web 应用等，以提高数据访问速度和系统性能。

// 一、工作原理
// LRU 算法通过维护一个数据项列表来实现缓存淘汰策略。这个列表按照数据项的使用时间进行排序，
// 最近最少使用的数据项被放在列表的末尾。当缓存满时，操作系统会将列表中的数据项进行淘汰，即将列表中的最后一个数据项从缓存中移除。

// 二、实现方式
// LRU 算法可以通过多种方式实现，其中最简单的是使用哈希表和双向链表。
// 在哈希表中，每个数据项都有一个对应的键值对，通过键值对可以快速定位到数据项在链表中的位置。
// 双向链表则用来存储数据项的顺序关系，即最近使用的数据在链表的头部，最少使用的数据在链表的尾部。
// 当数据项被访问时，如果该数据项在链表中存在，则将其移动到链表头部；
// 如果该数据项不存在，则先将其插入到链表头部，然后再将其加入到哈希表中。当缓存满时，将链表尾部的数据项从链表中移除即可。

// 三、优缺点
// LRU 算法的优点主要有：
// 实现简单：LRU 算法的实现方式相对简单，只需要维护一个数据项列表即可。
// 效率较高：由于 LRU 算法是基于最近使用过的数据进行淘汰的，因此可以有效地减少访问延迟。
// 缓存利用率高：LRU 算法能够充分利用缓存空间，尽可能地减少缓存未命中的情况。
// 缺点：
// 缓存污染：如果某些数据项被频繁访问，而其他数据项则很少被访问，这些频繁访问的数据项就会占据缓存空间，导致其他有用的数据项被淘汰。这种现象被称为 “缓存污染”。
// 无法处理突发流量：当某些数据项突然变得非常热门时，这些数据项可能会迅速占据所有缓存空间，导致其他数据项被淘汰。此时 LRU 算法无法应对这种突发流量，导致缓存命中率下降。
// 对新数据的处理不佳：新数据在首次访问时可能无法立即被放入缓存中，因为需要先将现有数据项移动到链表头部再插入新数据。这可能导致新数据的访问延迟增加。
// 为了解决上述问题，一些改进的 LRU 算法被提出，如使用时间戳记录数据项的访问时间、使用哈希表和平衡二叉树等数据结构进行快速查找和移动等。这些改进可以进一步提高 LRU 算法的性能和适用性。

// 四、应用场景
// LRU 算法广泛应用于各种缓存系统，如数据库、Web 应用等。
// 在数据库中，LRU 算法可以用于实现查询缓存，提高数据库查询速度；
// 在 Web 应用中，LRU 算法可以用于实现页面缓存，减少对服务器的请求次数，提高网页加载速度。
// 此外，LRU 算法还可以应用于各种需要快速访问大量数据的场景中。


// https://leetcode.cn/problems/lru-cache/
// 146. LRU 缓存
// labuladong 题解
// 思路
// 中等
// 相关标签
// 相关企业
// 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
// 实现 LRUCache 类：
// LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
// int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
// void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
// 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

// 示例：
// 输入
// ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
// [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
// 输出
// [null, null, null, 1, null, -1, null, -1, 3, 4]

// 解释
// LRUCache lRUCache = new LRUCache(2);
// lRUCache.put(1, 1); // 缓存是 {1=1}
// lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
// lRUCache.get(1);    // 返回 1
// lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
// lRUCache.get(2);    // 返回 -1 (未找到)
// lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
// lRUCache.get(1);    // 返回 -1 (未找到)
// lRUCache.get(3);    // 返回 3
// lRUCache.get(4);    // 返回 4
 

// 提示：
// 1 <= capacity <= 3000
// 0 <= key <= 10000
// 0 <= value <= 10^5
// 最多调用 2 * 10^5 次 get 和 put